import * as immuGrpc from '../immu-grpc/index.js';
import * as ver from '../immu-grpc-verification/index.js';
import { grpcEntryToValTxEntryAndRefTxEntry } from '../immu-grpc-entry/index.js';
export function createGetValRefAndVerification(client) {
    const verifiableGetValRefGrpc = immuGrpc.unaryCall.createVerifiableGet(client);
    /**
     *
     */
    return function getValRefAndVerification(props) {
        return verifiableGetValRefGrpc({
            request: {
                keyRequest: {
                    atTx: props.dbTxesWindow?.endId,
                    sinceTx: props.dbTxesWindow?.startId,
                    atRevision: props.revisionId,
                    key: props.key,
                    noWait: props.options?.dontWaitForIndexer,
                },
                proveSinceTx: props.refTxId,
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('VerifiableTx__Output must be defined'))
            .then(grpcVerEntry => {
            const grpcVerTx = grpcVerEntry.verifiableTx;
            if (grpcVerTx == undefined) {
                throw 'verifiableTx must be defined.';
            }
            const grpcTx = grpcVerTx.tx;
            const grpcProof = grpcVerTx.dualProof;
            if (grpcTx?.header == undefined) {
                throw 'transaction must be defined';
            }
            if (grpcProof?.sourceTxHeader == undefined) {
                throw 'sourceTxHeader must be defined';
            }
            if (grpcProof?.targetTxHeader == undefined) {
                throw 'targetTxHeader must be defined';
            }
            const grpcTxHeader = grpcTx.header;
            const grpcEntry = grpcVerEntry.entry;
            if (grpcEntry == undefined) {
                throw 'entry must be defined';
            }
            const valEntryAndMaybeRefEntry = grpcEntryToValTxEntryAndRefTxEntry(grpcEntry);
            // const grpcInclusionProof = grpcVerEntry.inclusionProof
            // if(grpcInclusionProof == undefined) {
            //     throw 'inclusionProof must be defined.'
            // }
            // const verificationOneOfEntries: immu.VerificationEntriesOneOf = {
            //     type:                   'one-of',
            //     allEntriesMht:          grpcTxHeader.eH,
            //     allEntriesCount:        grpcTxHeader.nentries,
            //     entryId:                grpcInclusionProof.leaf,
            //     entryInclusionProof:    grpcInclusionProof.terms,
            //     entry: valEntryAndMaybeRefEntry.refTxEntry == undefined
            //         ? valEntryAndMaybeRefEntry.valTxEntry
            //         : valEntryAndMaybeRefEntry.refTxEntry,
            // }
            const verificationEntries = ver.grpcTxEntriesToVerificationEntries({
                txEntries: grpcTx.entries,
                allEntriesMht: grpcTxHeader.eH,
            });
            const verificationTx = ver.grpcDualProofToVerificationTx({
                grpcProof: grpcProof,
                grpcTx: grpcTxHeader,
                refHash: props.refHash,
                refTxId: props.refTxId,
            });
            const verification = {
                // entries:    verificationOneOfEntries,
                entries: verificationEntries,
                tx: verificationTx
            };
            const transaction = {
                id: verificationTx.tx.id,
                timestamp: verificationTx.tx.timestamp,
                entries: verificationEntries.allEntries,
            };
            return {
                transaction,
                valEntry: valEntryAndMaybeRefEntry.valTxEntry,
                refEntry: valEntryAndMaybeRefEntry.refTxEntry,
                verification,
            };
        });
    };
}
//# sourceMappingURL=verification-get-val-ref.js.map