import * as igd from '../immu-grpc-db.js';
import * as immuGrpc from '../immu-grpc/index.js';
export function createCreateDb(client) {
    const createDbGrpc = immuGrpc.unaryCall.createCreateDatabaseV2(client);
    return function createDb(props) {
        return createDbGrpc({
            request: {
                name: props.database,
                ifNotExists: props.ifNotExists,
                settings: igd.dbUpdatableSettingsToGrpcDbSettings(props.settings)
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('CreateDatabaseResponse__Output must be defined'))
            .then(resp => {
            return {
                database: resp.name,
                alreadyExisted: resp.alreadyExisted,
                settings: igd.grpcDbSettingsToDbSettings(resp.settings),
            };
        });
    };
}
export function createDeleteDb(client) {
    const deleteDbGrpc = immuGrpc.unaryCall.createDeleteDatabase(client);
    return function createDb(props) {
        return deleteDbGrpc({
            request: {
                database: props.database
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('DeleteDatabaseResponse__Output must be defined'))
            .then(resp => {
            return resp.database;
        });
    };
}
export function createFlushDbIndex(client) {
    const flushIndexGrpc = immuGrpc.unaryCall.createFlushIndex(client);
    return function flushDbIndex(props) {
        return flushIndexGrpc({
            request: {
                cleanupPercentage: props.cleanupPercentage,
                synced: props.synced,
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('FlushIndexResponse__Output must be defined'))
            .then(resp => {
            return resp.database;
        });
    };
}
export function createCompactDbIndex(client) {
    const compactIndexGrpc = immuGrpc.unaryCall.createCompactIndex(client);
    return function compactDbIndex(props) {
        return compactIndexGrpc({
            request: {},
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('Empty__Output must be defined'))
            .then(resp => { });
    };
}
export function createGetDbSettings(client) {
    const getDatabaseSettingsV2Grpc = immuGrpc.unaryCall.createGetDatabaseSettingsV2(client);
    return function getDbSettings(props) {
        return getDatabaseSettingsV2Grpc({
            request: {},
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('DatabaseSettingsResponse__Output must be defined'))
            .then(resp => {
            return {
                database: resp.database,
                settings: igd.grpcDbSettingsToDbSettings(resp.settings)
            };
        });
    };
}
export function createListDbs(client) {
    const databaseListV2Grpc = immuGrpc.unaryCall.createDatabaseListV2(client);
    return function getDbSettings(props) {
        return databaseListV2Grpc({
            request: {},
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('DatabaseListResponseV2__Output must be defined'))
            .then(resp => resp.databases.map(grpcDbRunInfoToDbRunInfo));
    };
}
function grpcDbRunInfoToDbRunInfo(props) {
    return {
        database: props.name,
        isLoaded: props.loaded,
        settings: igd.grpcDbSettingsToDbSettings(props.settings)
    };
}
export function createLoadDb(client) {
    const loadDatabaseGrpc = immuGrpc.unaryCall.createLoadDatabase(client);
    return function getDbSettings(props) {
        return loadDatabaseGrpc({
            request: {
                database: props.database,
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('LoadDatabaseResponse__Output must be defined'))
            .then(resp => resp.database);
    };
}
export function createUnloadDb(client) {
    const unloadDatabaseGrpc = immuGrpc.unaryCall.createUnloadDatabase(client);
    return function getDbSettings(props) {
        return unloadDatabaseGrpc({
            request: {
                database: props.database,
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('UnloadDatabaseResponse__Output must be defined'))
            .then(resp => { resp.database; });
    };
}
export function createSetDbSettings(client) {
    const updateDatabaseV2Grpc = immuGrpc.unaryCall.createUpdateDatabaseV2(client);
    return function setDbSettings(props) {
        return updateDatabaseV2Grpc({
            request: {
                database: props.database,
                settings: igd.dbUpdatableSettingsToGrpcDbSettings(props.settings)
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('UpdateDatabaseResponse__Output must be defined'))
            .then(resp => ({
            database: resp.database,
            settings: igd.grpcDbSettingsToDbSettings(resp.settings)
        }));
    };
}
export function createGetDbCurrentState(client) {
    const stateGrpc = immuGrpc.unaryCall.createCurrentState(client);
    return function getDbCurrentState(props) {
        return stateGrpc({
            request: {},
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('UpdateDatabaseResponse__Output must be defined'))
            .then(resp => ({
            database: resp.db,
            txHash: resp.txHash,
            txId: resp.txId,
            signature: resp.signature == null ? undefined : resp.signature,
        }));
    };
}
//# sourceMappingURL=db.js.map