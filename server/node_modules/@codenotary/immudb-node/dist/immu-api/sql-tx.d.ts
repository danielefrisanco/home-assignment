import type * as igrpc from '@codenotary/immudb-node-grpcjs';
import type * as immu from '../types/index.js';
import * as grpcjs from '@grpc/grpc-js';
export declare type SqlTxNewProps = {
    /**
     * Mode of interactive transaction:
     * - `ReadOnly` declares that transaction will not modify db,
     * - `WriteOnly` declares that transaction will not depend on reading db,
     * - `ReadWrite` declares that transaction may read and write to db.
     */
    mode?: "ReadOnly" | "WriteOnly" | "ReadWrite";
};
export declare function createSqlTxNew(client: igrpc.ImmuServiceClient): (props: SqlTxNewProps & {
    credentials: grpcjs.CallCredentials;
}) => Promise<immu.TransactionTokens>;
export declare function createSqlTxCommit(client: igrpc.ImmuServiceClient): (props: {
    credentials: grpcjs.CallCredentials;
}) => Promise<{
    tx: immu.TxCore | undefined;
    firstPK: immu.SqlNamedValue[];
    lastPK: immu.SqlNamedValue[];
    updatedRowsCount: number;
}>;
export declare function createSqlTxRollback(client: igrpc.ImmuServiceClient): (props: {
    credentials: grpcjs.CallCredentials;
}) => Promise<void>;
export declare type SqlTxExecProps = {
    /**
     * Operation options.
     */
    options?: {
        /**
         * Do not wait for immudb to update database indexes, setting this
         * value to `true` may cause operation to speed up in exchange for
         * stale database latest keys values.
         *
         * For example geting key value will return key value pointed by
         * indexer. If indexer is not up to date, returned value may be not
         * latest value.
         *
         * Default value is `false`.
         */
        dontWaitForIndexer?: boolean;
    };
    /**
     * Sql statements to execute. (May be multiple, all will be executed inside
     * automatic transaction.)
     */
    sql: string;
    /**
     * sql params
     *
     * ```ts
     *
     * sqlExec({
     *   sql: 'select * from customer where id = :clientId',
     *   params: [
     *     {name: ':clientId', type: 'Int64', value: Long.fromValue(10)},
     *   ]
     * })
     * ```
     */
    params?: immu.SqlNamedValue[];
};
export declare function createSqlTxExec(client: igrpc.ImmuServiceClient): (props: SqlTxExecProps & {
    credentials: grpcjs.CallCredentials;
}) => Promise<void>;
export declare type SqlTxQueryProps = {
    /**
     * Sql statements to execute. (May be multiple, all will be executed inside
     * automatic transaction.)
     */
    sql: string;
    /**
     * sql params
     *
     * ```ts
     *
     * sqlExec({
     *   sql: 'select * from customer where id = :clientId',
     *   params: [
     *     {name: ':clientId', type: 'Int64', value: Long.fromValue(10)},
     *   ]
     * })
     * ```
     */
    params?: immu.SqlNamedValue[];
    /**
     * Does this query operation needs refreshed index
     * or not? (perhaps earlier operation was also read).
     */
    reuseSnapshot?: boolean;
};
export declare function createSqlTxQuery(client: igrpc.ImmuServiceClient): (props: SqlTxQueryProps & {
    credentials: grpcjs.CallCredentials;
}) => Promise<immu.SqlNamedValue[][]>;
//# sourceMappingURL=sql-tx.d.ts.map