import * as immuGrpc from '../immu-grpc/index.js';
import * as igt from '../immu-grpc-tx/index.js';
import * as igs from '../immu-grpc-sql/index.js';
export function createSqlTxNew(client) {
    const sqlTxNewGrpc = immuGrpc.unaryCall.createNewTx(client);
    /**
     * Starts new interactive transation. If successful returns
     * transaction token used  to associate further grpc calls with
     * interactive transaction.
     */
    return function sqlTxNew(props) {
        return sqlTxNewGrpc({
            request: {
                mode: props.mode,
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('NewTxResponse__Output    must be defined'))
            .then(grpcNewTxResponse => {
            const token = {
                transactionid: grpcNewTxResponse.transactionID
            };
            return token;
        });
    };
}
export function createSqlTxCommit(client) {
    const sqlTxCommitGrpc = immuGrpc.unaryCall.createCommit(client);
    /**
     * Commits interactive transaction.
     * `credentials` must inslude interactive transaction token.
     */
    return function sqlTxCommit(props) {
        return sqlTxCommitGrpc({
            request: {},
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('CommittedSQLTx__Output must be defined'))
            .then(grpcSqlCommitedTxResult => {
            // execution may not cause effects!!!
            const tx = grpcSqlCommitedTxResult.header == undefined
                ? undefined
                : igt.grpcTxHeaderToTxCore(grpcSqlCommitedTxResult.header);
            const updatedRowsCount = grpcSqlCommitedTxResult.updatedRows;
            const firstPK = igs.grpcSqlObjectNamedValueToNamedValues(grpcSqlCommitedTxResult.firstInsertedPKs);
            const lastPK = igs.grpcSqlObjectNamedValueToNamedValues(grpcSqlCommitedTxResult.lastInsertedPKs);
            return {
                tx,
                firstPK,
                lastPK,
                updatedRowsCount,
            };
        });
    };
}
export function createSqlTxRollback(client) {
    const sqlTxRollbackGrpc = immuGrpc.unaryCall.createRollback(client);
    /**
     * Rollbacks interactive transaction.
     * `credentials` must inslude interactive transaction token.
     */
    return function sqlTxRollback(props) {
        return sqlTxRollbackGrpc({
            request: {},
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('Empty__Output must be defined'))
            .then(res => { });
    };
}
export function createSqlTxExec(client) {
    const sqlTxExecGrpc = immuGrpc.unaryCall.createTxSqlExec(client);
    return function sqlTxExec(props) {
        return sqlTxExecGrpc({
            request: {
                sql: props.sql,
                params: props.params?.map(igs.sqlNamedValueToGrpcSqlNamedParam),
                noWait: props.options?.dontWaitForIndexer,
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('Empty__Output must be defined'))
            .then(res => { });
    };
}
export function createSqlTxQuery(client) {
    const sqlTxQueryGrpc = immuGrpc.unaryCall.createTxSqlQuery(client);
    return function sqlTxQuery(props) {
        return sqlTxQueryGrpc({
            request: {
                sql: props.sql,
                params: props.params?.map(igs.sqlNamedValueToGrpcSqlNamedParam),
                reuseSnapshot: props.reuseSnapshot
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('SQLQueryResult__Output must be defined'))
            .then(grpcSqlRows => {
            return igs.grpcQueryResultToListoOfSqlNamedValues(grpcSqlRows);
        });
    };
}
//# sourceMappingURL=sql-tx.js.map