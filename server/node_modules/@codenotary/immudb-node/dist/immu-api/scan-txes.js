import * as immuGrpc from '../immu-grpc/index.js';
import Long from 'long';
import * as ige from '../immu-grpc-entry/index.js';
export function createScanTxes(client) {
    const scanTxesGrpc = immuGrpc.unaryCall.createTxScan(client);
    /**
     * For usage with {@link getAtTxId} returned entries will have keys prefixed
     * by one byte if those entries are KVs or Refs, from ZSet keys prefix
     * should not be stripped.
     */
    return function scanTxes(props) {
        return scanTxesGrpc({
            request: {
                desc: props.sortDescending,
                limit: props.limit,
                noWait: props.dontWaitForLatestKeys,
                sinceTx: props.seenSinceTxId,
                entriesSpec: props.kvOrRefEntryAction || props.sqlEntryAction || props.zEntryAction
                    ? {
                        kvEntriesSpec: props.kvOrRefEntryAction
                            ? { action: props.kvOrRefEntryAction }
                            : undefined,
                        sqlEntriesSpec: props.sqlEntryAction
                            ? { action: props.sqlEntryAction }
                            : undefined,
                        zEntriesSpec: props.zEntryAction
                            ? { action: props.zEntryAction }
                            : undefined,
                    }
                    : undefined,
                initialTx: props.scanStartAtTxId,
            },
            options: {
                credentials: props.credentials,
            }
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('TxList__Output must be defined'))
            .then(txes => txes.txs);
    };
}
export function createScanDb(client) {
    const scanTxes = createScanTxes(client);
    /**
     *
     */
    return async function scanDB(props) {
        const allEntries = await scanTxes({
            credentials: props.credentials,
            scanStartAtTxId: props.scanStartAtTxId ?? Long.fromInt(1, true),
            dontWaitForLatestKeys: props.dontWaitForLatestKeys,
            seenSinceTxId: props.seenSinceTxId,
            sortDescending: props.sortDescending,
            limit: props.limit,
            kvOrRefEntryAction: 'RAW_VALUE',
            zEntryAction: 'RAW_VALUE',
            sqlEntryAction: 'RAW_VALUE',
        })
            .then(out => out.flatMap(tx => tx.entries.map((grpcEntry, entryIndex) => {
            return ige.grpcTxEntryToTxEntry(tx, grpcEntry);
        })));
        return allEntries;
    };
}
//# sourceMappingURL=scan-txes.js.map