import * as immuGrpc from '../immu-grpc/index.js';
import * as ige from '../immu-grpc-entry/index.js';
import * as igt from '../immu-grpc-tx/index.js';
export function createGetValRef(client) {
    const getGrpc = immuGrpc.unaryCall.createGet(client);
    /**
     * Sets key-value pair(s) for given session defined in credentials
     */
    return function getValRef(props) {
        return getGrpc({
            request: {
                key: props.key,
                atRevision: props.revision,
                atTx: props.seenAtTxId,
                sinceTx: props.seenSinceTxId,
                noWait: props.options?.dontWaitForIndexer,
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('tx must be defined'))
            .then(ige.grpcEntryToValTxEntryAndRefTxEntry);
    };
}
export function createGetValRefs(client) {
    const getAllGrpc = immuGrpc.unaryCall.createGetAll(client);
    /**
     * Sets key-value pair(s) for given session defined in credentials
     */
    return function getValRefs(props) {
        return getAllGrpc({
            request: {
                keys: props.keys,
                sinceTx: props.seenSinceTxId,
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('tx must be defined'))
            .then(grpcEntries => grpcEntries.entries.map(ige.grpcEntryToValTxEntryAndRefTxEntry));
    };
}
export function createGetTxWithEntries(client) {
    const getTxByIdGrpc = immuGrpc.unaryCall.createTxById(client);
    /**
     * Sets key-value pair(s) for given session defined in credentials
     */
    return function getTxWithEntries(props) {
        return getTxByIdGrpc({
            request: {
                tx: props.txId,
                keepReferencesUnresolved: props.resolveRefs,
                noWait: props?.options?.dontWaitForIndexer,
                sinceTx: props.seenSinceTxId,
                entriesSpec: props.kvOrRefEntryAction
                    || props.sqlEntryAction
                    || props.zEntryAction
                    ? {
                        kvEntriesSpec: props.kvOrRefEntryAction
                            ? { action: props.kvOrRefEntryAction }
                            : undefined,
                        sqlEntriesSpec: props.sqlEntryAction
                            ? { action: props.sqlEntryAction }
                            : undefined,
                        zEntriesSpec: props.zEntryAction
                            ? { action: props.zEntryAction }
                            : undefined,
                    }
                    : undefined,
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('Tx__Output must be defined'))
            .then(grpcEntries => grpcEntries);
    };
}
export function createGetTxGenericEntries(client) {
    const getTxByIdGrpc = immuGrpc.unaryCall.createTxById(client);
    /**
     *
     */
    return function getTxGenericEntries(props) {
        return getTxByIdGrpc({
            request: {
                tx: props.txId,
                keepReferencesUnresolved: props.resolveRefs,
                noWait: props?.options?.dontWaitForIndexer,
                sinceTx: props.seenSinceTxId,
                entriesSpec: {
                    kvEntriesSpec: { action: 'RAW_VALUE' },
                    zEntriesSpec: { action: 'RAW_VALUE' },
                    sqlEntriesSpec: { action: 'RAW_VALUE' },
                },
            },
            options: {
                credentials: props.credentials,
            },
        })
            .then(maybeResponse => maybeResponse
            ? maybeResponse
            : Promise.reject('Tx__Output must be defined'))
            .then(grpcTx => {
            const tx = igt.grpcTxHeaderToTxCore(grpcTx.header);
            return grpcTx.entries.map((grpcEntry) => {
                return ige.grpcTxEntryToTxEntry(grpcTx, grpcEntry);
            });
        });
    };
}
export function createGetValRefStreaming(client) {
    const streamGetGrpc = immuGrpc.readerCall.createStreamGet(client);
    /**
     * Example usage:
     *
     * ```ts
     *
     * const buffs: Buffer[] = []
     * const kvStream = getValRefStreaming({key: Buffer.from('some key')})
     * for await (const chunk of kvStream) {
     *     buffs.push(chunk.content)
     * }
     * // buf will contain ValEntry
     * // or resolved referenced ValEntry
     * // encoded as StreamKVEntry !!!
     * const referencedValEntry = toKVEntry(Buffer.concat(buffs))
     * console.log(ref)
     *
     * ```
     *
     */
    return function getValRefStreaming(props) {
        return streamGetGrpc({
            request: {
                key: props.key,
                atRevision: props.revision,
                atTx: props.seenAtTxId,
                sinceTx: props.seenSinceTxId,
                noWait: props.options?.dontWaitForIndexer,
            },
            credentials: props.credentials,
        });
    };
}
//# sourceMappingURL=get.js.map