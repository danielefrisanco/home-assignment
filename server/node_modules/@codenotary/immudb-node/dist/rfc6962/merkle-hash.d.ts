/// <reference types="node" />
/**
 * The hashing algorithm is SHA-256. The input to the Merkle Tree Hash is a list
 * of data entries; these entries will be hashed to form the leaves of the
 * Merkle Hash Tree. The output is a single 32-byte Merkle Tree Hash.
 *
 * Alghoritm is as follows:
 *
 * ```
 * MTH({})      = SHA-256()
 * MTH({d(0)})  = SHA-256(0x00 || d(0))
 * MTH(D(n))    = SHA-256(0x01 || MTH(D[0:k]) || MTH(D[k:n]))
 * ```
 *
 * Symbols:
 * * `D(n) = [d(0), d(1), ..., d(n-1)]`
 * * `||` is concatenation
 * * `k` = the largest power of two smaller than n
 * * `D(k1:k2) = [d(k1), d(k1+1),..., d(k2-1)]`.
 *
 * @example
 * const merkleHash256BytesBuffer = merkelHashOf(Buffer.from('Quick brown fox'))
 *
 * @see [rfc6962](https://datatracker.ietf.org/doc/html/rfc6962#section-2.1)
 * @param things List of things to merkle hash
 * @returns merkle hash
 */
export declare function merkelHashOf(things: Buffer[]): Buffer;
/**
 * Finds highest power of 2 smaller
 * than or equal to n. No input checks are performed,
 * so illegal input will return not relevant value.
 *
 * @param n Positive 32bit integer equall or greater than 1
 * @returns Closest power of two value on the left
 */
export declare function maxPowOf2LessOrEqTo(n: number): number;
//# sourceMappingURL=merkle-hash.d.ts.map