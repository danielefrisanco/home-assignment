/// <reference types="node" />
import { Buffer } from 'node:buffer';
export declare type PK = TimespanPK | IntPK | StringPK | BlobPK | BooleanPK;
export declare type PKDecode = typeof decodePKInt | typeof decodePKString | typeof decodePKBlob | typeof decodePKBoolean | typeof decodePKTimespan;
/**
 * Example:
 *
 * ```ts
 * const decodedId1Id2PK = decodePK({
 *     decoders: [
 *         {name: 'id1' as const, decode: decodePKInt},
 *         {name: 'id2' as const, decode: decodePKString},
 *     ],
 *     pkBinary: Buffer.from([
 *         0x80, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
 *         0x80, 0x6b, 0x6b, 0x6b, 0x00, 0x00, 0x00, 0x03
 *     ])
 * })
 * // [
 * //     {name: 'id1', data: {type: 'int',    isNotNull: true,  data: -2} },
 * //     {name: 'id2', data: {type: 'string', isNotNull: false, data: 'kkk'} },
 * // ]
 * ```
 */
export declare function decodePK<T extends string>(props: {
    decoders: {
        name: T;
        decode: PKDecode;
    }[];
    pkBinary: Buffer;
}): {
    name: T;
    data: PK;
}[];
export declare type IntPK = {
    type: 'int';
    isNotNull: boolean;
    data: number;
};
export declare function decodePKInt(b: Buffer, offset?: number): {
    pk: IntPK;
    rest: Buffer;
};
export declare type BooleanPK = {
    type: 'boolean';
    isNotNull: boolean;
    data: boolean;
};
export declare function decodePKBoolean(b: Buffer, offset?: number): {
    pk: BooleanPK;
    rest: Buffer;
};
export declare type TimespanPK = {
    type: 'timespan';
    isNotNull: boolean;
    data: Date;
};
export declare function decodePKTimespan(b: Buffer, offset?: number): {
    pk: TimespanPK;
    rest: Buffer;
};
export declare type StringPK = {
    type: 'string';
    isNotNull: boolean;
    data: string;
};
/**
 * String is encoded as fallows:
 * - isNotNull - first byte
 * - string - string byte length bytes
 * - stringLength.
 *
 * This can not be decoded from buffer heaving additional things
 * after previous structure without taking some assumptions.
 *
 *
 * This decoder assumes that:
 * - length is less than 0xffffff (max of lower 3 bytes of 4 byte UInt32)
 * - string is utf8 encoded
 * - string does not contain null character.
 *
 * This would mean that first 0 will be highest byte of UInt32 representing length.
 *
 *
 */
export declare function decodePKString(b: Buffer, offset?: number): {
    pk: StringPK;
    rest: Buffer;
};
export declare type BlobPK = {
    type: 'blob';
    isNotNull: boolean;
    data: Buffer;
};
/**
 * Blob is encoded as fallows:
 * - isNotNull - first byte
 * - blob - string byte length bytes
 * - blobLength.
 *
 * This can not be decoded from buffer heaving additional things.
 * This function can be used for blobs that are:
 * - last PK component
 * - only PK component
 *
 */
export declare function decodePKBlob(b: Buffer, offset?: number): {
    pk: BlobPK;
    rest: Buffer;
};
//# sourceMappingURL=pk-decode-auto.d.ts.map