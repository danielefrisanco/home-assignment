import { kvmhToEntry } from './kvmh.js';
export function grpcZEntryToZSetEntryAndValTxEntryAndRefTxEntry(entry) {
    if (entry.entry == undefined) {
        throw 'ZEntry__Output["entry"]: Entry__Output must be defined';
    }
    if (typeof entry.score !== 'number') {
        throw 'score must be number';
    }
    const zSetEntry = {
        type: 'zSet',
        version: '1',
        zSet: entry.set,
        referredKeyScore: entry.score,
        referredAtTxId: entry.atTx,
        referredKey: entry.key,
    };
    return {
        zSetEntry,
        ...grpcEntryToValTxEntryAndRefTxEntry(entry.entry),
    };
}
export function grpcTxEntryToTxEntry(tx, grpcEntry) {
    if (tx.header == undefined) {
        throw 'transaction must be defined';
    }
    const entry = grpcTxEntryToEntry(grpcEntry);
    const foundableEntry = {
        ...entry,
        id: tx.header.id,
    };
    return foundableEntry;
}
export function grpcTxEntryToEntry(grpcEntry) {
    return kvmhToEntry({
        prefixedKey: grpcEntry.key,
        prefixedVal: grpcEntry.value,
        meta: grpcMetaToEntryMeta(grpcEntry.metadata),
        valHash: grpcEntry.hValue,
    });
}
export function grpcEntryToValTxEntryAndRefTxEntry(entry) {
    const valTxEntry = {
        type: 'val',
        version: '1',
        key: entry.key,
        val: entry.value,
        meta: grpcMetaToEntryMeta(entry.metadata),
        expired: entry.expired,
        revision: entry.revision,
        id: entry.tx,
    };
    if (entry.referencedBy == undefined) { // value entry
        return { valTxEntry };
    }
    const refTxEntry = {
        type: 'ref',
        version: '1',
        key: entry.referencedBy.key,
        referredKey: entry.key,
        referredAtTxId: entry.referencedBy.atTx,
        meta: grpcMetaToEntryMeta(entry.referencedBy.metadata),
        revision: entry.referencedBy.revision,
        id: entry.referencedBy.tx,
    };
    return { valTxEntry, refTxEntry };
}
export function grpcMetaToEntryMeta(props) {
    if (props == null) {
        return undefined;
    }
    return {
        deleted: props.deleted,
        nonIndexable: props.nonIndexable,
        expiresAt: props.expiration === null
            ? undefined
            : props.expiration.expiresAt
    };
}
//# sourceMappingURL=index.js.map