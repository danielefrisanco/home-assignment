/// <reference types="node" />
import * as api from './immu-api/index.js';
import * as grpcjs from '@grpc/grpc-js';
import * as igrpc from '@codenotary/immudb-node-grpcjs';
import type * as immu from './types/index.js';
export declare class Client {
    private readonly conf;
    private readonly immuGrpcClient;
    private readonly immuGrpcApi;
    private sessionTokens?;
    private callCredentials?;
    constructor(conf: Config);
    /**
     * Gets and caches session tokens.
     */
    private getSessionTokens;
    /**
     * Creates and caches session credentials.
     */
    private getCallCredentials;
    /**
     * Clears stored session tokens and credentials and closses session
     * with immudb
     */
    close(): Promise<void>;
    /**
     * Asks immudb to not close (idle?) connection.
     */
    keepAlive(): Promise<void>;
    /**
     * Sets multiple ValEntries, RefEntries or ZSetEntries in one transaction.
     */
    setValRefZSetEntries(props: api.SetEntryProps): Promise<{
        txEntries: (immu.ValTxEntry | immu.RefTxEntry | immu.ZSetTxEntry)[];
        tx: immu.TxCore;
    }>;
    /**
     * Sets multiple ValEntries or ZSetEntries in one transaction.
     */
    setValZSetEntriesStreaming(props: api.SetEntriesStreamingProps): Promise<immu.TxCore>;
    /**
     * Sets all value entries in one transaction.
     */
    setValEntries(props: api.SetValEntryProps): Promise<{
        valEntries: immu.ValTxEntry[];
        txCore: immu.TxCore;
    }>;
    /**
     * Sets multiple ValEntries in one transaction.
     */
    setValEntriesStreaming(props: api.SetValEntriesStreamingProps): Promise<immu.TxCore>;
    /**
     * Sets ZEntry in one transaction.
     */
    setZSetEntry(props: api.SetZSetEntryProps): Promise<{
        zSetTxEntry: immu.ZSetTxEntry;
        tx: immu.TxCore;
    }>;
    /**
     * Sets RefEntry in one transaction.
     */
    setRefEntry(props: api.SetRefEntryProps): Promise<{
        ref: immu.RefTxEntry;
        txCore: immu.TxCore;
    }>;
    /**
     * Deletes keys or references to keys in one transaction.
     *
     * Key or reference to key **marked** as deleted will be ignored
     * by the indexer (e.g. {@link Client.getValRef} method) seeing database
     * at this operation transaction and further transactions if key
     * will not be set once more.
     */
    deleteValRef(props: api.DeleteValRefProps): Promise<immu.TxEntry[]>;
    /**
     * Scans database VEntries and RefEntries in one transaction.
     */
    scanValRefEntries(props?: api.ScanValRefEntriesProps): Promise<{
        valTxEntry: immu.TxContext & immu.ValEntry & immu.IndexerInfo;
        refTxEntry?: (immu.TxContext & immu.RefEntry & immu.IndexerInfo) | undefined;
    }[]>;
    /**
     * Scans database VEntries and RefEntries in one transaction.
     * Returns output as stream.
     */
    scanValRefEntriesStreaming(props: api.ScanValRefEntriesProps): Promise<AsyncGenerator<igrpc.Chunk__Output, any[], unknown>>;
    /**
     * Scans database ZEntries in one transaction.
     */
    scanZEntries(props: api.ScanZSetEntriesProps): Promise<{
        zSetEntry: immu.ZSetEntry;
        valTxEntry: immu.ValTxEntry;
        refTxEntry?: immu.RefTxEntry | undefined;
    }[]>;
    /**
     * Scans database ZEntries in one transaction.
     * Returns output as stream.
     */
    scanZEntriesStreaming(props: api.ScanZSetEntriesProps): Promise<AsyncGenerator<igrpc.Chunk__Output, any[], unknown>>;
    /**
     * Scans database transactions in one transaction. This is most fundamental
     * operation of immudb.
     *
     * Result is composed in following way:
     * - entries are filtered out for actions:
     *   - `EXCLUDE`,
     * - entries go ordered into `entries` array fild for actions:
     *   - `RAW_VALUE`,
     *   - `ONLY_DIGEST`,
     *   - `undefined`,
     * - KV entries go ordered into `kvEntries` array fild for
     *   `kvOrRefEntryAction` action:
     *   - `RESOLVE`,
     * - Z entries go ordered into `zEntries` array fild for `zEntryAction`
     *   action:
     *   - `RESOLVE`,
     *
     * Transactions are ordered with transaction id, however depending on
     * operation parameters it may not be sequential (`RESOLVE` action will
     * cause values to go to separate arrays, `EXCLUDE` will filter them out).
     *
     * To obtain sequential transactions ordering set all actions as:
     * - `RAW_VALUE` or
     * - `ONLY_DIGEST`.
     */
    scanTxes(props: api.ScanTxesProps): Promise<igrpc.Tx__Output[]>;
    /**
     * Scans database transaction entries.
     *
     * Result is composed in following way:
     * - entries are filtered out for actions:
     *   - `EXCLUDE`,
     * - entries go ordered into `entries` array fild for actions:
     *   - `RAW_VALUE`,
     *   - `ONLY_DIGEST`,
     *   - `undefined`,
     * - KV entries go ordered into `kvEntries` array fild for
     *   `kvOrRefEntryAction` action:
     *   - `RESOLVE`,
     * - Z entries go ordered into `zEntries` array fild for `zEntryAction`
     *   action:
     *   - `RESOLVE`,
     *
     * To obtain sequential entries ordering set all actions to:
     * - `RAW_VALUE` or
     * - `ONLY_DIGEST`.
     */
    getTxWithEntries(props: api.GetTxWithEntriesProps): Promise<igrpc.Tx__Output>;
    /**
     * Gets value, ref, zSet entries of transaction heaving specified id.
     * Obtained entries are verifiable.
     */
    getTxGenericEntries(props: api.GetTxGenericEntriesProps): Promise<immu.TxEntry[]>;
    /**
     * Gets value for provided key in one transaction. Key may refer to value or
     * reference.
     */
    getValRef(props: api.GetValRefProps): Promise<{
        valTxEntry: immu.TxContext & immu.ValEntry & immu.IndexerInfo;
        refTxEntry?: (immu.TxContext & immu.RefEntry & immu.IndexerInfo) | undefined;
    }>;
    /**
     * Gets value for provided key in one transaction. Key may refer to value or
     * reference.
     */
    getValRefStreaming(props: api.GetValRefProps): Promise<AsyncGenerator<igrpc.Chunk__Output, any[], unknown>>;
    /**
     * Gets values and refs for all provided keys.
     */
    getValRefs(props: api.GetAllValRefsProps): Promise<{
        valTxEntry: immu.TxContext & immu.ValEntry & immu.IndexerInfo;
        refTxEntry?: (immu.TxContext & immu.RefEntry & immu.IndexerInfo) | undefined;
    }[]>;
    /**
     * Scans all database entries in one transaction.
     */
    scanDbEntries(props?: api.ScanDBProps): Promise<immu.TxEntry[]>;
    /**
     * Scans entry history.
     */
    scanHistory(props: api.GetHistoryProps): Promise<{
        valTxEntry: immu.TxContext & immu.ValEntry & immu.IndexerInfo;
        refTxEntry?: (immu.TxContext & immu.RefEntry & immu.IndexerInfo) | undefined;
    }[]>;
    /**
     * Scans entry history.
     * Returns output as stream.
     */
    scanHistoryStreaming(props: api.GetHistoryProps): Promise<AsyncGenerator<igrpc.Chunk__Output, any[], unknown>>;
    /**
     * Sql queries DB in one transaction. (Multiple result sets?)
     */
    sqlQuery(props: api.SqlQueryProps): Promise<immu.SqlNamedValue[][]>;
    /**
     * Queries current db for sql tables.
     */
    sqlQueryTables(props: api.SqlQueryProps): Promise<immu.SqlNamedValue[][]>;
    /**
     * Queries sql table schema.
     */
    sqlQueryTable(table: string): Promise<immu.SqlNamedValue[][]>;
    /**
     * Executes sql batch as one transaction.
     */
    sqlExec(props: api.SqlExecProps): Promise<{
        subTxes: {
            tx: immu.TxCore | undefined;
            firstPK: immu.SqlNamedValue[];
            lastPK: immu.SqlNamedValue[];
            updatedRowsCount: number;
        }[];
        isInTransaction: boolean;
    }>;
    /**
     * Executes interactive sql transaction. Transaction will be:
     * - commited if no errors will be thrown,
     * - rolled back if:
     *   - there are sql errors
     *   - user throws
     *
     * Committing transaction example:
     *
     * ```ts
     *
     * client.executeSqlTx(
     *     'ReadWrite',
     *     async txApi => {
     *         const testTable = await txApi.query({sql: `
     *             select * from testtable;
     *         `})
     *         txApi.exec({sql: `
     *             insert into testtable
     *                 (id, value)
     *             values
     *                 (1, 'yoyo');
     *         `})
     *     }
     * )
     *
     * // testtable with inserted rows
     * console.log(await client.sqlQuery({sql: `
     *     select * from testtable;
     * `}))
     *
     * ```
     *
     * Rolling back transaction example:
     *
     * ```ts
     *
     * const txRes = await client.executeSqlTx(
     *     'ReadWrite',
     *     async txApi => {
     *         const testTable = await txApi.query({sql: `
     *             select * from testtable;
     *         `})
     *         txApi.exec({sql: `
     *             insert into testtable
     *                 (id, value)
     *             values
     *                 (1, 'yoyo');
     *         `})
     *         throw 'Changed my decision, don't update testtable'
     *
     *         console.log('This will not be executed')
     *     }
     * )
     *
     * console.log(txRes)
     * // Changed my decision, don't update testtable
     *
     * // testtable without inserted rows
     * console.log(await client.sqlQuery({sql: `
     *     select * from testtable;
     * `}))
     *
     * ```
     *
     */
    executeSqlTx(mode: "ReadOnly" | "WriteOnly" | "ReadWrite", run: (txApi: {
        query(props: api.SqlTxQueryProps): Promise<immu.SqlNamedValue[][]>;
        exec(props: api.SqlTxExecProps): Promise<void>;
    }) => Promise<void>): Promise<string | {
        tx: immu.TxCore | undefined;
        firstPK: immu.SqlNamedValue[];
        lastPK: immu.SqlNamedValue[];
        updatedRowsCount: number;
    }>;
    /**
     * Creates immudb server user
     */
    createUser(props: api.CreateUsersProps): Promise<immu.UserCredentials & immu.DatabasePermission>;
    /**
     * Deletes (deactivates) immudb server user, can also activate user.
     */
    deleteUser(props: api.SetUserActiveProps): Promise<api.SetUserActiveProps & {
        credentials: grpcjs.CallCredentials;
    }>;
    /**
     * Lists immudb server users, can also activate user.
     */
    listUsers(): Promise<immu.UserInfo[]>;
    /**
     * Sets immudb server user permissions.
     */
    setUserDbPermissions(props: api.SetUserDbPermissionsProps): Promise<api.SetUserDbPermissionsProps & {
        credentials: grpcjs.CallCredentials;
    }>;
    /**
     * Sets immudb server user password.
     */
    setUserPassword(props: api.SetUserPasswordProps): Promise<string>;
    /**
     * Creates database as immudb server.
     */
    createDb(props: api.CreateDatabaseProps): Promise<{
        database: string;
        alreadyExisted: boolean;
        settings: immu.DatabaseSettings;
    }>;
    /**
     * Deletes database as immudb server.
     */
    deleteDb(props: api.DeleteDatabaseProps): Promise<string>;
    /**
     * Loads database at immudb server.
     */
    loadDb(props: api.LoadDbProps): Promise<string>;
    /**
     * Unloads database at immudb server.
     */
    unloadDb(props: api.UnloadDbProps): Promise<void>;
    /**
     * Flushes current database index.
     */
    flushDbIndex(props: api.FlushDatabaseIndexProps): Promise<string>;
    /**
     * Compacts current database index.
     */
    compactDbIndex(): Promise<void>;
    /**
     * Lists all immudb server databases.
     */
    listDbs(): Promise<immu.DBRuntimeInfo[]>;
    /**
     * Gets current database state.
     */
    getDbCurrentState(): Promise<{
        database: string;
        /**
         * Scans database VEntries and RefEntries in one transaction.
         */
        txHash: Buffer;
        txId: import("long");
        signature: igrpc.Signature__Output | undefined;
    }>;
    /**
     * Gets current database settings.
     */
    getDbSettings(): Promise<{
        database: string;
        settings: immu.DatabaseSettings;
    }>;
    /**
     * Sets database settings.
     */
    setDbSettings(props: api.SetDbSettingsProps): Promise<{
        database: string;
        settings: immu.DatabaseSettings;
    }>;
    /**
     * Replicates transaction.
     */
    replicateTx(props: api.ReplicateTxProps): Promise<immu.TxCore>;
    /**
     * Exports transaction.
     */
    exportTx(props: api.ExportTxProps): Promise<AsyncGenerator<igrpc.Chunk__Output, any[], unknown>>;
    /**
     * Gets Tx, its entries and its verification structure, by looking for
     * transaction id.
     */
    getTxAndVerification(props: api.GetTxAndVerificationProps): Promise<{
        transaction: immu.Transaction;
        verification: immu.Verification;
    }>;
    /**
     * Gets SqlRowEntry and its verification structure by looking
     * for sql row primary key (which can be composite).
     */
    getSqlRowEntryAndVerification(props: api.GetSqlRowEntryAndVerificationProps): Promise<{
        transaction: immu.Transaction;
        verification: immu.Verification;
    }>;
    /**
     * Gets ValEntry or RefEntry (and ref associated ValEntry) and its (val or
     * ref) verification structure by looking for ValEntry or RefEntry key.
     */
    getValRefAndVerification(props: api.GetValRefAndVerificationProps): Promise<{
        transaction: immu.Transaction;
        valEntry: immu.TxContext & immu.ValEntry & immu.IndexerInfo;
        refEntry: (immu.TxContext & immu.RefEntry & immu.IndexerInfo) | undefined;
        verification: immu.Verification;
    }>;
    /**
     * Sets all value entries in one transaction.
     *
     * Returns entries set and its verification structure.
     */
    setValEntriesGetVerification(props: api.SetValEntryProps & api.ProofRequestProps): Promise<{
        transaction: immu.Transaction;
        verification: immu.Verification;
    }>;
    /**
     * Sets RefEntry in one transaction.
     *
     * Returns RefEntry set and its verification structure.
     */
    setRefEntryGetVerification(props: api.SetRefEntryProps & api.ProofRequestProps): Promise<{
        transaction: immu.Transaction;
        verification: immu.Verification;
        refEntry: immu.RefEntry;
    }>;
    /**
     * Sets ZSetEntry in one transaction.
     *
     * Returns ZSetEntry set and its verification structure.
     */
    setZSetEntryGetVerification(props: api.SetZSetEntryProps & api.ProofRequestProps): Promise<{
        transaction: immu.Transaction;
        verification: immu.Verification;
        zSetEntry: immu.ZSetEntry;
    }>;
}
/**
 * Session configuration.
 */
export declare type Config = {
    /**
     * Immudb server host address.
     */
    host: string;
    /**
     * Immudb server port number.
     */
    port?: number;
    /**
     * Immudb server instance user name.
     */
    user: string;
    /**
     * Immudb server instance user password.
     */
    password: string;
    /**
     * Immudb server instance database name.
     */
    database: string;
};
/**
 * Config for local develpoment.
 */
export declare const devConfig: Config;
//# sourceMappingURL=immu-client.d.ts.map