import * as grpc from '@grpc/grpc-js';
import * as common from '../common/index.js';
import events from 'node:events';
export function promisifyGrpcReaderAsync(callFunction) {
    return async function* grpcReaderAsync(props) {
        const grpcReader = callFunction(props.request, props.requestMetadata ?? new grpc.Metadata(), {
            deadline: common.unixTimeNowAfterMS(props.operationTimeoutMS),
            credentials: props.credentials ? props.credentials : undefined,
        });
        const info = [];
        grpcReader.on('metadata', (metadata) => info.push('stream metadata', metadata));
        grpcReader.on('status', (status) => info.push('stream status', status));
        grpcReader.on('close', () => info.push('stream close'));
        grpcReader.on('pause', () => info.push('stream pause'));
        grpcReader.on('resume', () => info.push('stream resume'));
        const ac = new AbortController();
        grpcReader.once('end', () => {
            info.push('stream end');
            ac.abort({ type: 'end' });
        });
        grpcReader.once('error', (err) => {
            info.push('stream error');
            ac.abort({ type: 'err', err });
        });
        try {
            let chunk;
            for await (chunk of grpcReader) {
                info.push('stream chunk');
                yield chunk;
            }
        }
        catch (err) {
            if (ac.signal.aborted) {
                switch (ac.signal.reason.type) {
                    case 'end': return info;
                    case 'err': throw { err: ac.signal.reason.err, info };
                }
            }
            else {
                throw { err, info };
            }
        }
        return info;
    };
}
export function promisifyGrpcReaderAsyncOnData(callFunction) {
    return async function* grpcReaderAsync(props) {
        const grpcReader = callFunction(props.request, props.requestMetadata ?? new grpc.Metadata(), {
            deadline: common.unixTimeNowAfterMS(props.operationTimeoutMS),
            credentials: props.credentials ? props.credentials : undefined,
        });
        const info = [];
        grpcReader.on('metadata', (metadata) => info.push('stream metadata', metadata));
        grpcReader.on('status', (status) => info.push('stream status', status));
        grpcReader.on('close', () => info.push('stream close'));
        grpcReader.on('pause', () => info.push('stream pause'));
        grpcReader.on('resume', () => info.push('stream resume'));
        const ac = new AbortController();
        grpcReader.once('end', () => {
            info.push('stream end');
            ac.abort({ type: 'end' });
        });
        grpcReader.once('error', (err) => {
            info.push('stream error');
            ac.abort({ type: 'err', err });
        });
        try {
            let chunk;
            for await (chunk of events.on(grpcReader, 'data', { signal: ac.signal })) {
                info.push('stream data');
                yield chunk;
            }
        }
        catch (err) {
            if (ac.signal.aborted) {
                switch (ac.signal.reason.type) {
                    case 'end': return info;
                    case 'err': throw { err: ac.signal.reason.err, info };
                }
            }
            else {
                throw { err, info };
            }
        }
        return info;
    };
}
export function promisifyGrpcReaderAsyncOnReadable(callFunction) {
    return async function* grpcReaderAsync(props) {
        const grpcReader = callFunction(props.request, props.requestMetadata ?? new grpc.Metadata(), {
            deadline: common.unixTimeNowAfterMS(props.operationTimeoutMS),
            credentials: props.credentials ? props.credentials : undefined,
        });
        const info = [];
        grpcReader.on('metadata', (metadata) => info.push('stream metadata', metadata));
        grpcReader.on('status', (status) => info.push('stream status', status));
        grpcReader.on('close', () => info.push('stream close'));
        grpcReader.on('pause', () => info.push('stream pause'));
        grpcReader.on('resume', () => info.push('stream resume'));
        const ac = new AbortController();
        grpcReader.once('end', () => {
            info.push('stream end');
            ac.abort({ type: 'end' });
        });
        grpcReader.once('error', (err) => {
            info.push('stream error');
            ac.abort({ type: 'err', err });
        });
        try {
            let chunk;
            for await (const _ of events.on(grpcReader, 'readable', { signal: ac.signal })) {
                info.push('stream readable');
                while ((chunk = grpcReader.read()) != null) {
                    yield chunk;
                }
            }
        }
        catch (err) {
            if (ac.signal.aborted) {
                switch (ac.signal.reason.type) {
                    case 'end': return;
                    case 'err': throw ac.signal.reason.err;
                }
            }
            else {
                throw err;
            }
        }
        return info;
    };
}
export function simplePromisifyGrpcReaderOnReadable(callFunction) {
    return function simpleGrpcReaderOnReadable(props) {
        return new Promise((resolve, reject) => {
            const grpcReader = callFunction(props.request, props.requestMetadata ?? new grpc.Metadata(), {
                deadline: common.unixTimeNowAfterMS(props.operationTimeoutMS),
                credentials: props.credentials ? props.credentials : undefined,
            });
            const info = [];
            grpcReader.on('metadata', (metadata) => info.push('stream metadata:', metadata));
            grpcReader.on('status', (status) => info.push('stream status:', status));
            grpcReader.on('close', () => info.push('stream close:'));
            grpcReader.on('pause', () => info.push('stream pause:'));
            grpcReader.on('resume', () => info.push('stream resume:'));
            const chunks = [];
            // 'readable' handler (and no 'data' handler) so stream in paused mode
            grpcReader.on('readable', () => {
                info.push('stream readable');
                let chunk;
                while ((chunk = grpcReader.read()) != null) {
                    chunks.push(chunk);
                }
            });
            grpcReader.on('end', () => {
                info.push('stream end');
                resolve({ response: chunks, info });
            });
            grpcReader.on('error', (err) => {
                info.push('stream error');
                reject({ err, info });
            });
        });
    };
}
export function simplePromisifyGrpcReaderOnData(callFunction) {
    return function simpleGrpcReaderOnData(props) {
        return new Promise((resolve, reject) => {
            const grpcReader = callFunction(props.request, props.requestMetadata ?? new grpc.Metadata(), {
                deadline: common.unixTimeNowAfterMS(props.operationTimeoutMS),
                credentials: props.credentials ? props.credentials : undefined,
            });
            const info = [];
            grpcReader.on('metadata', (metadata) => info.push('stream metadata:', metadata));
            grpcReader.on('status', (status) => info.push('stream status:', status));
            grpcReader.on('close', () => info.push('stream close:'));
            grpcReader.on('pause', () => info.push('stream pause:'));
            grpcReader.on('resume', () => info.push('stream resume:'));
            const chunks = [];
            // 'data' handler so stream in flowing mode
            grpcReader.on('data', (chunk) => {
                info.push('stream data');
                chunks.push(chunk);
            });
            grpcReader.on('end', () => {
                info.push('stream end');
                resolve({ response: chunks, info });
            });
            grpcReader.on('error', (err) => {
                info.push('stream error');
                reject({ err, info });
            });
        });
    };
}
//# sourceMappingURL=promisifyGrpcReaderAsync.js.map