import * as grpc from '@grpc/grpc-js';
import * as common from '../common/index.js';
export function promisifyGrpcReader(callFunction) {
    return function grpcReaderCall(props) {
        return new Promise((resolve, reject) => {
            if (props.cancelSignal?.aborted === true) {
                return reject(new common.OperationCanceledError('Operation cancelled by client before started.'));
            }
            const call = callFunction(props.request, props.requestMetadata ?? new grpc.Metadata(), {
                deadline: common.unixTimeNowAfterMS(props.operationTimeoutMS),
                credentials: props.credentials ? props.credentials : undefined,
            });
            const context = {
                data: [],
                info: [],
                call,
                resolve,
                reject,
                cleanup,
            };
            const handleResponseMetadata = createHandleResponseMetadata(context);
            const handleResponseStatus = createHandleResponseStatus(context);
            const handleResponseData = createHandleResponseData(context);
            const handleAbortSignal = createHandleAbortSignal(context);
            const handleResponseError = createHandleResponseError(context);
            const handleResponseEnd = createHandleResponseEnd(context);
            call.addListener('error', handleResponseError);
            call.addListener('metadata', handleResponseMetadata);
            call.addListener('data', handleResponseData);
            call.addListener('status', handleResponseStatus);
            call.addListener('end', handleResponseEnd);
            props.cancelSignal?.addEventListener('abort', handleAbortSignal);
            function cleanup() {
                props.cancelSignal?.removeEventListener('abort', handleAbortSignal);
                call.removeListener('error', handleResponseError);
                call.removeListener('end', handleResponseEnd);
                call.removeListener('status', handleResponseStatus);
                call.removeListener('data', handleResponseData);
                call.removeListener('metadata', handleResponseMetadata);
            }
        });
    };
}
function createHandleResponseData(context) {
    return function handleResponseData(chunk) {
        context.data.push(chunk);
    };
}
function createHandleResponseMetadata(context) {
    return function handleResponseMetadata(metadata) {
        context.info.push(metadata);
    };
}
function createHandleResponseStatus(context) {
    return function handleResponseStatus(status) {
        context.info.push(status);
    };
}
function createHandleResponseEnd(context) {
    return function handleResponseEnd() {
        context.info.push('stream end event');
        context.cleanup();
        context.resolve({
            response: context.data,
            info: context.info,
        });
    };
}
function createHandleResponseError(context) {
    return function handleResponseError(err) {
        context.info.push('stream error event');
        context.cleanup();
        context.reject(new common.InternalError(err, context.info));
    };
}
function createHandleAbortSignal(context) {
    return function handleCallAbort(ev) {
        context.info.push('abort signal event');
        context.cleanup();
        context.call.cancel();
        return context.reject(new common.OperationCanceledError('Operation canceled by client. Call was canceled', context.info));
    };
}
//# sourceMappingURL=promisifyGrpcReader.js.map