/// <reference types="node" />
import Long from 'long';
/**
 * Computes MHT root from:
 * - leaf `leaf`,
 * - at posision `leafId`,
 * - for MHT size `lastLeafId`
 * - using Merkle Audit Path `inclusionProofNodes`.
 */
export declare function rootFromInclusionProof(proofData: {
    /**
     * List of nodes needed to compute MHT path starting at leaf.
     */
    inclusionProofNodes: Buffer[];
    /**
     * Id (number) of leaf.
     * Number is encoded as UInt64  and represented by type Long in js.
     */
    leafId: Long;
    /**
     * Size of Merkle Tree.
     * Number is UInt64, represented by type Long in js.
     */
    lastLeafId: Long;
    /**
     * Leaf node value for which proof inclusion
     */
    leaf: Buffer;
}): Buffer;
/**
 * Computes MHT root from:
 * - leaf `iLeaf`,
 * - at posision `i`,
 * - for MHT size `j`
 * - using Merkle Audit Path `iProof`.
 *
 * This function is 1:1 rewrite of similar function
 * in Java client
 */
export declare function evalInclusion(props: {
    iProof: Buffer[];
    i: Long;
    j: Long;
    iLeaf: Buffer;
}): Buffer;
//# sourceMappingURL=inclusionProof.d.ts.map